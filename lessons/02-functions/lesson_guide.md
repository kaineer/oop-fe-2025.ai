# Краткий конспект занятия - Функции в JavaScript

## Ключевые концепции

### Создание функций
- **Function Declaration** - `function имя() {}`
- **Function Expression** - `const имя = function() {}`
- **Стрелочные функции** - `const имя = () => {}`
- **Другие способы** - конструктор Function, методы объектов

### Вызов функций
- **Прямой вызов** - `функция()`
- **call/apply** - `функция.call(контекст, аргументы)`, `функция.apply(контекст, [аргументы])`
- **bind** - создает новую функцию с привязанным контекстом

### Контекст выполнения
- **this** в обычных функциях зависит от способа вызова
- **Стрелочные функции** не имеют своего this, берут его из внешней области
- **bind** фиксирует контекст

### Синтаксис функций
- Параметры и возвращаемые значения
- Деструктуризация в параметрах: `function({name, age})`
- Rest параметры: `function(...args)`

## Примеры для демонстрации

### Базовые функции
```javascript
function sum(a, b) {
    return a + b;
}
```

### Стрелочные функции
```javascript
const sum = (a, b) => a + b;
```

### Функции с контекстом
```javascript
const obj = {
    name: 'test',
    getName: function() { return this.name; }
};
```

### Деструктуризация параметров
```javascript
function getUserInfo({name, age}) {
    return `Имя: ${name}, Возраст: ${age}`;
}
```

## Интересные факты

- **Свойства функций**: `length` (количество параметров) и `name` (имя функции)
- **Arguments**: автоматически создаваемый объект с аргументами функции
- **Event**: глобальный объект события в браузере

## Вопросы для обсуждения

1. В чем разница между function declaration и function expression?
2. Почему стрелочные функции не имеют своего this?
3. Когда использовать call vs apply?
4. Зачем нужен bind и в каких случаях он полезен?
5. Как работает деструктуризация в параметрах функций?
6. Что такое rest параметры и когда их использовать?

## Типичные ошибки

- Потеря контекста при передаче методов объектов как колбэков
- Использование this в стрелочных функциях без понимания контекста
- Путаница между call и apply
- Неправильное использование bind
- Ошибки при деструктуризации несуществующих свойств

## Практические упражнения

### Задача 1: Сумма двух чисел
```javascript
function sum(a, b) {
    return a + b;
}
```

### Задача 2: Вывод информации о человеке
```javascript
function printPersonInfo(name, age) {
    console.log(`Имя: ${name}`);
    console.log(`Возраст: ${age}`);
}
```

### Задача 3: Нахождение минимального числа
```javascript
function findMin(a, b, c) {
    return Math.min(a, b, c);
}
```

### Задача 4: Стрелочная функция sum
```javascript
const sum = (a, b) => a + b;
```

### Задача 5: Анонимная функция
```javascript
const anonymousFunc = function() {
    console.log('Анонимная функция');
};
```
*Примечание: При присваивании функции константе, функция получает имя константы. Для действительно анонимной функции можно передать ее как параметр:*
```javascript
setTimeout(function() {
    console.log('Это действительно анонимная функция');
}, 1000);
```

### Задача 6: Композиция функций
```javascript
function compose(f, g) {
    return function(x) {
        return g(f(x));
    };
}
```

### Задача 7: Получение свойства name
```javascript
function getName(obj) {
    return obj.name;
}
```

## Дополнительные вопросы для проверки

- Создайте функцию, которая принимает неопределенное количество чисел и возвращает их сумму
- Напишите функцию, использующую деструктуризацию для извлечения нескольких свойств объекта
- Создайте метод объекта, который сохраняет контекст при передаче как колбэк
- Объясните разницу в поведении this в обычной и стрелочной функциях